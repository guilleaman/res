{
  "farejadorv2-2024.06.29": {
    "mappings": {
      "dynamic": "true",
      "dynamic_date_formats": [
        "strict_date_optional_time",
        "yyyy/MM/dd HH:mm:ss Z||yyyy/MM/dd Z"
      ],
      "dynamic_templates": [],
      "date_detection": true,
      "numeric_detection": false,
      "properties": {
        "@timestamp": {
          "type": "date",
          "format": "strict_date_optional_time"
        },
        "UsernameCPF": {
          "type": "text",
          "fields": {
            "keyword": {
              "type": "keyword",
              "ignore_above": 256
            }
          }
        },
        "cClientAddr": {
          "type": "text",
          "fields": {
            "keyword": {
              "type": "keyword",
              "ignore_above": 256
            }
          }
        },
        "cClientId": {
          "type": "text",
          "fields": {
            "keyword": {
              "type": "keyword",
              "ignore_above": 256
            }
          }
        },
        "cCorrelationId": {
          "type": "text",
          "fields": {
            "keyword": {
              "type": "keyword",
              "ignore_above": 256
            }
          }
        },
        "cFase": {
          "type": "long"
        },
        "cUserId": {
          "type": "text",
          "fields": {
            "keyword": {
              "type": "keyword",
              "ignore_above": 256
            }
          }
        },
        "host": {
          "properties": {
            "ip": {
              "type": "text",
              "fields": {
                "keyword": {
                  "type": "keyword",
                  "ignore_above": 256
                }
              }
            }
          }
        },
        "k8s:host": {
          "type": "text",
          "fields": {
            "keyword": {
              "type": "keyword",
              "ignore_above": 256
            }
          }
        },
        "mCategory": {
          "type": "text",
          "fields": {
            "keyword": {
              "type": "keyword",
              "ignore_above": 256
            }
          }
        },
        "mEventId": {
          "type": "text",
          "fields": {
            "keyword": {
              "type": "keyword",
              "ignore_above": 256
            }
          }
        },
        "mOutcome": {
          "type": "text",
          "fields": {
            "keyword": {
              "type": "keyword",
              "ignore_above": 256
            }
          }
        },
        "mServiceId": {
          "type": "text",
          "fields": {
            "keyword": {
              "type": "keyword",
              "ignore_above": 256
            }
          }
        },
        "mSourceAddr": {
          "type": "text",
          "fields": {
            "keyword": {
              "type": "keyword",
              "ignore_above": 256
            }
          }
        },
        "mSourceId": {
          "type": "text",
          "fields": {
            "keyword": {
              "type": "keyword",
              "ignore_above": 256
            }
          }
        },
        "pHttpStatus": {
          "type": "text",
          "fields": {
            "keyword": {
              "type": "keyword",
              "ignore_above": 256
            }
          }
        },
        "severity": {
          "type": "text",
          "fields": {
            "keyword": {
              "type": "keyword",
              "ignore_above": 256
            }
          }
        },
        "time": {
          "type": "date"
        },
        "timestamp": {
          "type": "text"
        }
      }
    }
  },


{
  "took": 5,
  "timed_out": false,
  "_shards": {
    "total": 14,
    "successful": 14,
    "skipped": 0,
    "failed": 0
  },
  "hits": {
    "total": {
      "value": 0,
      "relation": "eq"
    },
    "max_score": null,
    "hits": []
  }
}

{
  "error": {
    "root_cause": [
      {
        "type": "x_content_parse_exception",
        "reason": """[8:62] Unexpected character ('-' (code 45)): was expecting comma to separate Object entries
 at [Source: (org.elasticsearch.common.io.stream.ByteBufferStreamInput); line: 8, column: 62]"""
      }
    ],
    "type": "x_content_parse_exception",
    "reason": "[8:57] [bool] failed to parse field [filter]",
    "caused_by": {
      "type": "x_content_parse_exception",
      "reason": """[8:62] Unexpected character ('-' (code 45)): was expecting comma to separate Object entries
 at [Source: (org.elasticsearch.common.io.stream.ByteBufferStreamInput); line: 8, column: 62]""",
      "caused_by": {
        "type": "json_parse_exception",
        "reason": """Unexpected character ('-' (code 45)): was expecting comma to separate Object entries
 at [Source: (org.elasticsearch.common.io.stream.ByteBufferStreamInput); line: 8, column: 62]"""
      }
    }
  },
  "status": 400
}


http://localhost:5000/search?cpf=<CPF_a_ser_buscado>&start_timestamp=<inicio>&end_timestamp=<fim>
2023-06-29T14:00:00

from flask import Flask, request, jsonify
from flask_restful import Resource, Api
from elasticsearch import Elasticsearch, TransportError
from datetime import datetime, timedelta
import os
import urllib3
import logging
import requests

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

app = Flask(__name__)
api = Api(app)

url_elasticsearch = os.getenv("ELASTICSEARCH_URL") 
token = os.getenv("ELASTICSEARCH_TOKEN")

es = Elasticsearch(
    [url_elasticsearch],
    headers={"Authorization": f'Basic {token}'},
    verify_certs=False
)

logging.basicConfig(level=logging.INFO)

class SearchResource(Resource):
    def get(self):
        cpf = request.args.get('cpf', '')
        if not cpf:
            return {'message': 'CPF is required'}, 400

        # Pega os timestamps da query string, ou usa valores default para caso não sejam passados
        start_timestamp = request.args.get('start_timestamp', (datetime.now() - timedelta(hours=2)).isoformat())
        end_timestamp = request.args.get('end_timestamp', datetime.now().isoformat())

        try:
            # Parse the timestamps to ensure they are in the correct format
            start_timestamp = datetime.fromisoformat(start_timestamp).strftime('%Y-%m-%dT%H:%M:%S')
            end_timestamp = datetime.fromisoformat(end_timestamp).strftime('%Y-%m-%dT%H:%M:%S')
        except ValueError:
            return {'message': 'Invalid date format'}, 400

        logging.info(f"Received CPF: {cpf}")
        logging.info(f"Searching logs from {start_timestamp} to {end_timestamp}")

        body = {
            "query": {
                "bool": {
                    "must": [
                        {"match": {"cUserId": cpf}}
                    ],
                    "filter": [
                        {"range": {"timestamp": {"gte": start_timestamp, "lte": end_timestamp, "format": "strict_date_optional_time"}}}
                    ]
                }
            },
            "size": 1000  # Ajuste esse valor conforme necessário para garantir que todos os logs sejam retornados
        }

        try:
            res = es.search(index="farejador*", body=body)
            logging.info(f"ElasticSearch response: {res}")

            hits = res['hits']['hits']

            response_data = [
                {
                    "user": hit["_source"]["cUserId"],
                    "correlationId": hit["_source"]["cCorrelationId"],
                    "fase": hit["_source"]["cFase"],
                    "group": hit["_source"]["mServiceId"],
                    "component": hit["_source"]["mSourceId"],
                    "httpStatus": hit["_source"]["pHttpStatus"],
                    "result": hit["_source"]["mOutcome"],
                    "timestamp": hit["_source"]["timestamp"]
                }
                for hit in hits
            ]

            logging.info(f"Response data: {response_data}")

            return jsonify(response_data)
        except TransportError as e:
            logging.error(f"ElasticSearch TransportError: {e.info}")
            return {'message': 'ElasticSearch error', 'error': e.info}, 500
        except Exception as e:
            logging.error(f"Unexpected error: {str(e)}")
            return {'message': 'Internal server error', 'error': str(e)}, 500

def get_cpf_by_hash(hash_value):
    url_base = os.getenv("SWAGGER_URL")
    url = url_base + hash_value
    try:
        response = requests.get(url, auth=(os.getenv("SWAGGER_USER"), os.getenv("SWAGGER_PASS")), verify=False)
        response.raise_for_status()  # Gera uma exceção para códigos de status HTTP 4xx/5xx
        service_response = response.json()
        return service_response['cpfCnpj']
    except requests.exceptions.RequestException as e:
        print(f"Erro na requisição: {e}")
        return None

class TransformCPF(Resource):
    def get(self, hash_value):
        cpf = get_cpf_by_hash(hash_value)
        if cpf:
            return {'cpf': cpf}, 200
        return {'message': 'CPF not found for given hash'}, 404

# Adiciona os recursos à API
api.add_resource(SearchResource, '/search')
api.add_resource(TransformCPF, '/transform/<string:hash_value>')

if __name__ == '__main__':
    app.run(debug=True)
