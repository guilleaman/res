
http://localhost:5000/search?cpf=<CPF_a_ser_buscado>&start_timestamp=<inicio>&end_timestamp=<fim>
2023-06-29T14:00:00

from flask import Flask, request, jsonify
from flask_restful import Resource, Api
from elasticsearch import Elasticsearch, TransportError
from datetime import datetime, timedelta
import os
import urllib3
import logging
import requests

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

app = Flask(__name__)
api = Api(app)

url_elasticsearch = os.getenv("ELASTICSEARCH_URL") 
token = os.getenv("ELASTICSEARCH_TOKEN")

es = Elasticsearch(
    [url_elasticsearch],
    headers={"Authorization": f'Basic {token}'},
    verify_certs=False
)

logging.basicConfig(level=logging.INFO)

class SearchResource(Resource):
    def get(self):
        cpf = request.args.get('cpf', '')
        if not cpf:
            return {'message': 'CPF is required'}, 400

        # Pega os timestamps da query string, ou usa valores default para caso não sejam passados
        start_timestamp = request.args.get('start_timestamp', (datetime.now() - timedelta(hours=2)).isoformat())
        end_timestamp = request.args.get('end_timestamp', datetime.now().isoformat())

        try:
            # Parse the timestamps to ensure they are in the correct format
            start_timestamp = datetime.fromisoformat(start_timestamp).strftime('%Y-%m-%dT%H:%M:%S')
            end_timestamp = datetime.fromisoformat(end_timestamp).strftime('%Y-%m-%dT%H:%M:%S')
        except ValueError:
            return {'message': 'Invalid date format'}, 400

        logging.info(f"Received CPF: {cpf}")
        logging.info(f"Searching logs from {start_timestamp} to {end_timestamp}")

        body = {
            "query": {
                "bool": {
                    "must": [
                        {"match": {"cUserId": cpf}}
                    ],
                    "filter": [
                        {"range": {"timestamp": {"gte": start_timestamp, "lte": end_timestamp, "format": "strict_date_optional_time"}}}
                    ]
                }
            },
            "size": 1000  # Ajuste esse valor conforme necessário para garantir que todos os logs sejam retornados
        }

        try:
            res = es.search(index="farejador*", body=body)
            logging.info(f"ElasticSearch response: {res}")

            hits = res['hits']['hits']

            response_data = [
                {
                    "user": hit["_source"]["cUserId"],
                    "correlationId": hit["_source"]["cCorrelationId"],
                    "fase": hit["_source"]["cFase"],
                    "group": hit["_source"]["mServiceId"],
                    "component": hit["_source"]["mSourceId"],
                    "httpStatus": hit["_source"]["pHttpStatus"],
                    "result": hit["_source"]["mOutcome"],
                    "timestamp": hit["_source"]["timestamp"]
                }
                for hit in hits
            ]

            logging.info(f"Response data: {response_data}")

            return jsonify(response_data)
        except TransportError as e:
            logging.error(f"ElasticSearch TransportError: {e.info}")
            return {'message': 'ElasticSearch error', 'error': e.info}, 500
        except Exception as e:
            logging.error(f"Unexpected error: {str(e)}")
            return {'message': 'Internal server error', 'error': str(e)}, 500

def get_cpf_by_hash(hash_value):
    url_base = os.getenv("SWAGGER_URL")
    url = url_base + hash_value
    try:
        response = requests.get(url, auth=(os.getenv("SWAGGER_USER"), os.getenv("SWAGGER_PASS")), verify=False)
        response.raise_for_status()  # Gera uma exceção para códigos de status HTTP 4xx/5xx
        service_response = response.json()
        return service_response['cpfCnpj']
    except requests.exceptions.RequestException as e:
        print(f"Erro na requisição: {e}")
        return None

class TransformCPF(Resource):
    def get(self, hash_value):
        cpf = get_cpf_by_hash(hash_value)
        if cpf:
            return {'cpf': cpf}, 200
        return {'message': 'CPF not found for given hash'}, 404

# Adiciona os recursos à API
api.add_resource(SearchResource, '/search')
api.add_resource(TransformCPF, '/transform/<string:hash_value>')

if __name__ == '__main__':
    app.run(debug=True)
