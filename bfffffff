from flask import Flask, request, jsonify
from flask_restful import Resource, Api
from elasticsearch import Elasticsearch, TransportError
from datetime import datetime, timedelta
import os
import urllib3
import logging

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

app = Flask(__name__)

url_elasticsearch = os.getenv("ELASTICSEARCH_URL")
token = os.getenv("ELASTICSEARCH_TOKEN")

es = Elasticsearch(
    [url_elasticsearch],
    headers={"Authorization": f'Basic {token}'},
    verify_certs=False
)

logging.basicConfig(level=logging.INFO)

class SearchResource(Resource):
    def get(self):
        cpf = request.args.get('cpf', '')
        if not cpf:
            return {'message': 'CPF is required'}, 400

        # Pega o timestamp atual e o intervalo dos últimos 10 minutos
        end_time = datetime.now()
        start_time = end_time - timedelta(minutes=10)

        # Pega os timestamps da query string se existirem
        start_timestamp = request.args.get('start_timestamp', start_time.isoformat())
        end_timestamp = request.args.get('end_timestamp', end_time.isoformat())

        logging.info(f"Received CPF: {cpf}")
        logging.info(f"Searching logs from {start_timestamp} to {end_timestamp}")

        body = {
            "query": {
                "bool": {
                    "must": [
                        {"match": {"cUserId": cpf}}
                    ],
                    "filter": [
                        {"range": {"timestamp": {"gte": start_timestamp, "lte": end_timestamp}}}
                    ]
                }
            },
            "size": 10000  # Ajuste esse valor conforme necessário para garantir que todos os logs sejam retornados
        }

        try:
            res = es.search(index="farejador*", body=body)
            logging.info(f"ElasticSearch response: {res}")

            hits = res['hits']['hits']

            response_data = [
                {
                    "user": hit["_source"]["cUserId"],
                    "correlationId": hit["_source"]["cCorrelationId"],
                    "fase": hit["_source"]["cFase"],
                    "group": hit["_source"]["mServiceId"],
                    "component": hit["_source"]["mSourceId"],
                    "httpStatus": hit["_source"]["pHttpStatus"],
                    "result": hit["_source"]["mOutcome"],
                    "timestamp": hit["_source"]["timestamp"]
                }
                for hit in hits
            ]

            logging.info(f"Response data: {response_data}")

            return jsonify(response_data)
        except TransportError as e:
            logging.error(f"ElasticSearch TransportError: {e.info}")
            return {'message': 'ElasticSearch error', 'error': e.info}, 500
        except Exception as e:
            logging.error(f"Unexpected error: {str(e)}")
            return {'message': 'Internal server error', 'error': str(e)}, 500

api = Api(app)
api.add_resource(SearchResource, '/search')

if __name__ == '__main__':
    app.run(debug=True)
